<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Drawing App</title>
<style>
:root{
--bg: #f3f4f6;
--panel: #ffffff;
--accent: #2563eb;
--muted: #6b7280;
}
html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}
body{display:flex;flex-direction:column;gap:12px;background:linear-gradient(180deg,#eef2ff 0%,var(--bg) 100%);padding:16px}
.app{max-width:1000px;margin:0 auto;width:100%;display:flex;flex-direction:column;gap:12px}
.toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;background:var(--panel);padding:10px;border-radius:12px;box-shadow:0 2px 8px rgba(16,24,40,0.06)}
.toolbar > *{margin:0}
.group{display:flex;gap:8px;align-items:center}
label{font-size:13px;color:var(--muted)}
input[type=color]{width:40px;height:36px;border-radius:6px;border:0;padding:0}
input[type=range]{width:140px}
button{background:#fff;border:1px solid #e6e7eb;padding:8px 10px;border-radius:8px;cursor:pointer;font-size:14px}
button:hover{box-shadow:0 2px 6px rgba(16,24,40,0.05)}
.btn-primary{background:var(--accent);color:white;border:0}
.canvas-wrap{background:var(--panel);padding:12px;border-radius:12px;box-shadow:0 2px 8px rgba(16,24,40,0.06);display:flex;flex-direction:column}
canvas{border-radius:8px;border:1px solid #e5e7eb;background:white;touch-action: none}
.meta{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px}
@media (max-width:640px){input[type=range]{width:100px}}
</style>
</head>
<body>
<div class="app">
<div class="toolbar" role="toolbar" aria-label="Drawing toolbar">
<div class="group">
<label for="color">Color</label>
<input id="color" type="color" value="#000000" title="Choose brush color"/>
</div>


<div class="group">
<label for="size">Size</label>
<input id="size" type="range" min="1" max="80" value="6" />
<span id="size-value">6</span> px
</div>


<div class="group">
<label for="mode">Mode</label>
<select id="mode" title="Draw or Erase">
<option value="draw">Draw</option>
<option value="erase">Eraser</option>
</select>
</div>


<div class="group">
<button id="undo">Undo</button>
<button id="redo">Redo</button>
<button id="clear">Clear</button>
</div>


<div class="group" style="margin-left:auto">
<button id="save" class="btn-primary">Save PNG</button>
</div>


</div>


<div class="canvas-wrap">
<div class="meta"><div>Drawing Canvas</div><div id="coords">x: -, y: -</div></div>
<canvas id="canvas" width="900" height="600"></canvas>
</div>


<div style="font-size:13px;color:var(--muted)">Tip: Use mouse or touch to draw. Use the Eraser mode to remove strokes. Undo stores recent snapshots (limit 25).</div>
</div>


<script>
// Basic drawing app implementation
(function(){
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorInput = document.getElementById('color');
const sizeInput = document.getElementById('size');
const sizeValue = document.getElementById('size-value');
const modeSelect = document.getElementById('mode');
const undoBtn = document.getElementById('undo');
const redoBtn = document.getElementById('redo');
const clearBtn = document.getElementById('clear');
const saveBtn = document.getElementById('save');
const coords = document.getElementById('coords');


// State
let drawing = false;
let lastX = 0, lastY = 0;
let strokeColor = colorInput.value;
let lineWidth = Number(sizeInput.value);
let mode = modeSelect.value; // draw or erase


// Undo / Redo stacks
const undoStack = [];
const redoStack = [];
const MAX_HISTORY = 25;


// Resize canvas to fit container while keeping drawing scale
function fitCanvasToContainer(){
const ratio = window.devicePixelRatio || 1;
const wrap = canvas.parentElement;
const maxWidth = Math.min(900, wrap.clientWidth - 24); // leave padding
const maxHeight = Math.max(300, Math.min(800, window.innerHeight - 260));
// maintain existing drawing scale by using an offscreen copy
const img = ctx.getImageData(0,0,canvas.width,canvas.height);
canvas.width = Math.floor(maxWidth * ratio);
canvas.height = Math.floor(maxHeight * ratio);
canvas.style.width = maxWidth + 'px';
canvas.style.height = maxHeight + 'px';
ctx.putImageData(img,0,0);
}


// Initial clear background
function clearCanvas(useHistory=true){
ctx.fillStyle = '#ffffff';
ctx.clearRect(0,0,canvas.width,canvas.height);
ctx.fillRect(0,0,canvas.width,canvas.height);
if(useHistory) pushHistory();
}


// Save snapshot for undo
function pushHistory(){
try{
if(undoStack.length >= MAX_HISTORY) undoStack.shift();
undoStack.push(canvas.toDataURL());
// once we push a new state, redo is invalid
redoStack.length = 0;
updateButtons();
}catch(e){console.warn('History push failed', e)}
}
function restoreFromDataURL(dataURL){
const img = new Image();
img.onload = function(){
// clear and draw
ctx.clearRect(0,0,canvas.width,canvas.height);
ctx.drawImage(img,0,0,canvas.width,canvas.height);
}
img.src = dataURL;
}


function updateButtons(){
undoBtn.disabled = undoStack.length === 0;
redoBtn.disabled = redoStack.length === 0;
}


// Drawing helpers
function setContext(){
ctx.lineJoin = 'round';
ctx.lineCap = 'round';
ctx.strokeStyle = (mode === 'erase') ? '#ffffff' : strokeColor;
ctx.lineWidth = lineWidth;
}


function startDrawing(x,y){
drawing = true;
lastX = x; lastY = y;
ctx.beginPath();
ctx.moveTo(lastX, lastY);
}


function drawLine(x,y){
if(!drawing) return;
ctx.lineTo(x,y);
ctx.stroke();
lastX = x; lastY = y;
}


function stopDrawing(){
if(drawing){
ctx.closePath();
drawing = false;
pushHistory();
}
}
// Mouse events
 function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;
  if(e.touches && e.touches.length){
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  return {x,y}
}

canvas.addEventListener('mousedown', (e)=>{
  setContext();
  const p = getPointerPos(e);
  startDrawing(p.x,p.y);
});

canvas.addEventListener('mousemove', (e)=>{
  const p = getPointerPos(e);
  coords.textContent = `x: ${Math.round(p.x)}, y: ${Math.round(p.y)}`;
  drawLine(p.x,p.y);});
window.addEventListener('mouseup', stopDrawing);


// Touch
canvas.addEventListener('touchstart', (e)=>{e.preventDefault(); setContext(); const p = getPointerPos(e); startDrawing(p.x,p.y);});
canvas.addEventListener('touchmove', (e)=>{e.preventDefault(); const p = getPointerPos(e); drawLine(p.x,p.y);});
canvas.addEventListener('touchend', (e)=>{e.preventDefault(); stopDrawing();});


// Controls
colorInput.addEventListener('input', (e)=>{strokeColor = e.target.value;});
sizeInput.addEventListener('input', (e)=>{lineWidth = Number(e.target.value); sizeValue.textContent = e.target.value;});
modeSelect.addEventListener('change', (e)=>{mode = e.target.value;});


undoBtn.addEventListener('click', ()=>{
if(undoStack.length){
const last = undoStack.pop();
// push current to redo
redoStack.push(canvas.toDataURL());
restoreFromDataURL(last);
updateButtons();
}
});


redoBtn.addEventListener('click', ()=>{
if(redoStack.length){
const last = redoStack.pop();
undoStack.push(canvas.toDataURL());
restoreFromDataURL(last);
updateButtons();
}
});


clearBtn.addEventListener('click', ()=>{
if(confirm('Clear the canvas?')){
clearCanvas(true);
}
});


saveBtn.addEventListener('click', ()=>{
const link = document.createElement('a');
link.download = 'drawing.png';
link.href = canvas.toDataURL('image/png');
link.click();
});
// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
if((e.ctrlKey||e.metaKey) && e.key === 'z'){ // undo
e.preventDefault(); undoBtn.click();
}else if((e.ctrlKey||e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))){
e.preventDefault(); redoBtn.click();
}
});


// initial setup
function init(){
// set white background
canvas.width = 900; canvas.height = 600;
canvas.style.width = '100%';
canvas.style.maxWidth = '900px';
ctx.fillStyle = '#ffffff';
ctx.fillRect(0,0,canvas.width,canvas.height);
pushHistory();
updateButtons();
}


init();


// Ensure canvas keeps content on resize: for simplicity, we won't scale drawing â€”
// advanced scaling would require redrawing on an offscreen canvas.
window.addEventListener('resize', ()=>{
// no-op: keep fixed internal resolution to avoid blurring
});


})();
</script>
</body>
</html>